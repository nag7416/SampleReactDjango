{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.$$ = exports.$ = undefined;\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\nexports.isReal = isReal;\nexports.isEl = isEl;\nexports.getEl = getEl;\nexports.createEl = createEl;\nexports.textContent = textContent;\nexports.insertElFirst = insertElFirst;\nexports.getElData = getElData;\nexports.hasElData = hasElData;\nexports.removeElData = removeElData;\nexports.hasElClass = hasElClass;\nexports.addElClass = addElClass;\nexports.removeElClass = removeElClass;\nexports.toggleElClass = toggleElClass;\nexports.setElAttributes = setElAttributes;\nexports.getElAttributes = getElAttributes;\nexports.getAttribute = getAttribute;\nexports.setAttribute = setAttribute;\nexports.removeAttribute = removeAttribute;\nexports.blockTextSelection = blockTextSelection;\nexports.unblockTextSelection = unblockTextSelection;\nexports.findElPosition = findElPosition;\nexports.getPointerPosition = getPointerPosition;\nexports.isTextNode = isTextNode;\nexports.emptyEl = emptyEl;\nexports.normalizeContent = normalizeContent;\nexports.appendContent = appendContent;\nexports.insertContent = insertContent;\nvar _document = require('global/document');\nvar _document2 = _interopRequireDefault(_document);\nvar _window = require('global/window');\nvar _window2 = _interopRequireDefault(_window);\nvar _guid = require('./guid.js');\nvar Guid = _interopRequireWildcard(_guid);\nvar _log = require('./log.js');\nvar _log2 = _interopRequireDefault(_log);\nvar _tsml = require('tsml');\nvar _tsml2 = _interopRequireDefault(_tsml);\nvar _obj = require('./obj');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n} /**\n   * @file dom.js\n   * @module dom\n   */\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  return (\n    // Both document and window will never be undefined thanks to `global`.\n    _document2['default'] === _window2['default'].document &&\n    // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof _document2['default'].createElement !== 'undefined'\n  );\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 1;\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return _document2['default'][method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = _document2['default'].querySelector(context);\n    }\n    var ctx = isEl(context) ? context : _document2['default'];\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Shorthand for document.getElementById()\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\n *\n * @param {string} id\n *         The id of the element to get\n *\n * @return {Element|null}\n *         Element with supplied ID or null if there wasn't one.\n */\nfunction getEl(id) {\n  if (id.indexOf('#') === 0) {\n    id = id.slice(1);\n  }\n  return _document2['default'].getElementById(id);\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n  var el = _document2['default'].createElement(tagName);\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      _log2['default'].warn((0, _tsml2['default'])(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n  if (content) {\n    appendContent(el, content);\n  }\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n *\n */\nfunction insertElFirst(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\n * Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {string}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getElData(el) {\n  var id = el[elIdAttr];\n  if (!id) {\n    id = el[elIdAttr] = Guid.newGUID();\n  }\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasElData(el) {\n  var id = el[elIdAttr];\n  if (!id) {\n    return false;\n  }\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeElData(el) {\n  var id = el[elIdAttr];\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasElClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addElClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasElClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeElClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleElClass(element, classToToggle, predicate) {\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasElClass(element, classToToggle);\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n  if (predicate) {\n    addElClass(element, classToToggle);\n  } else {\n    removeElClass(element, classToToggle);\n  }\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setElAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getElAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n      obj[attrName] = attrVal;\n    }\n  }\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  _document2['default'].body.focus();\n  _document2['default'].onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  _document2['default'].onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} Dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {Dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findElPosition(el) {\n  var box = void 0;\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n  var docEl = _document2['default'].documentElement;\n  var body = _document2['default'].body;\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findElPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return _document2['default'].createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = exports.$ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = exports.$$ = createQuerier('querySelectorAll');","map":{"version":3,"names":["exports","__esModule","$$","$","undefined","_templateObject","_taggedTemplateLiteralLoose","isReal","isEl","getEl","createEl","textContent","insertElFirst","getElData","hasElData","removeElData","hasElClass","addElClass","removeElClass","toggleElClass","setElAttributes","getElAttributes","getAttribute","setAttribute","removeAttribute","blockTextSelection","unblockTextSelection","findElPosition","getPointerPosition","isTextNode","emptyEl","normalizeContent","appendContent","insertContent","_document","require","_document2","_interopRequireDefault","_window","_window2","_guid","Guid","_interopRequireWildcard","_log","_log2","_tsml","_tsml2","_obj","obj","newObj","key","Object","prototype","hasOwnProperty","call","strings","raw","isNonBlankString","str","test","throwIfWhitespace","Error","classRegExp","className","RegExp","document","createElement","value","isObject","nodeType","createQuerier","method","selector","context","querySelector","ctx","id","indexOf","slice","getElementById","tagName","arguments","length","properties","attributes","content","el","getOwnPropertyNames","forEach","propName","val","warn","attrName","text","innerText","child","parent","firstChild","insertBefore","appendChild","elData","elIdAttr","Date","getTime","newGUID","e","element","classToCheck","classList","contains","classToAdd","add","trim","classToRemove","remove","split","filter","c","join","classToToggle","predicate","has","attrValue","tag","knownBooleans","attrs","i","name","attrVal","attribute","body","focus","onselectstart","box","getBoundingClientRect","parentNode","left","top","docEl","documentElement","clientLeft","scrollLeft","pageXOffset","clientTop","scrollTop","pageYOffset","Math","round","event","position","boxW","offsetWidth","boxH","offsetHeight","boxY","boxX","pageY","pageX","changedTouches","y","max","min","x","removeChild","Array","isArray","map","createTextNode","node"],"sources":["C:/Users/babu7/OneDrive/Desktop/djangoyoutube2/reelyoutube/frontend/node_modules/videojs-react/node_modules/video.js/es5/utils/dom.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.$$ = exports.$ = undefined;\n\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\nexports.isReal = isReal;\nexports.isEl = isEl;\nexports.getEl = getEl;\nexports.createEl = createEl;\nexports.textContent = textContent;\nexports.insertElFirst = insertElFirst;\nexports.getElData = getElData;\nexports.hasElData = hasElData;\nexports.removeElData = removeElData;\nexports.hasElClass = hasElClass;\nexports.addElClass = addElClass;\nexports.removeElClass = removeElClass;\nexports.toggleElClass = toggleElClass;\nexports.setElAttributes = setElAttributes;\nexports.getElAttributes = getElAttributes;\nexports.getAttribute = getAttribute;\nexports.setAttribute = setAttribute;\nexports.removeAttribute = removeAttribute;\nexports.blockTextSelection = blockTextSelection;\nexports.unblockTextSelection = unblockTextSelection;\nexports.findElPosition = findElPosition;\nexports.getPointerPosition = getPointerPosition;\nexports.isTextNode = isTextNode;\nexports.emptyEl = emptyEl;\nexports.normalizeContent = normalizeContent;\nexports.appendContent = appendContent;\nexports.insertContent = insertContent;\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _tsml = require('tsml');\n\nvar _tsml2 = _interopRequireDefault(_tsml);\n\nvar _obj = require('./obj');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; } /**\n                                                                                           * @file dom.js\n                                                                                           * @module dom\n                                                                                           */\n\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  return (\n\n    // Both document and window will never be undefined thanks to `global`.\n    _document2['default'] === _window2['default'].document &&\n\n    // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof _document2['default'].createElement !== 'undefined'\n  );\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 1;\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return _document2['default'][method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = _document2['default'].querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : _document2['default'];\n\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Shorthand for document.getElementById()\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\n *\n * @param {string} id\n *         The id of the element to get\n *\n * @return {Element|null}\n *         Element with supplied ID or null if there wasn't one.\n */\nfunction getEl(id) {\n  if (id.indexOf('#') === 0) {\n    id = id.slice(1);\n  }\n\n  return _document2['default'].getElementById(id);\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = _document2['default'].createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      _log2['default'].warn((0, _tsml2['default'])(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n *\n */\nfunction insertElFirst(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\n * Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {string}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = Guid.newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasElClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addElClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasElClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeElClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleElClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasElClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addElClass(element, classToToggle);\n  } else {\n    removeElClass(element, classToToggle);\n  }\n\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setElAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getElAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  _document2['default'].body.focus();\n  _document2['default'].onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  _document2['default'].onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} Dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {Dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findElPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = _document2['default'].documentElement;\n  var body = _document2['default'].body;\n\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findElPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return _document2['default'].createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = exports.$ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = exports.$$ = createQuerier('querySelectorAll');\n"],"mappings":"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gBAAgB,CAACsD,OAAO,CAAC,CAACG,OAAO,CAAC,UAAUgF,IAAI,EAAE;IAChD,OAAOlF,EAAE,CAACa,WAAW,CAACqE,IAAI,CAAC;EAC7B,CAAC,CAAC;EACF,OAAOlF,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrD,aAAaA,CAACqD,EAAE,EAAED,OAAO,EAAE;EAClC,OAAOrD,aAAa,CAACF,OAAO,CAACwD,EAAE,CAAC,EAAED,OAAO,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIlF,CAAC,GAAGH,OAAO,CAACG,CAAC,GAAGmE,aAAa,CAAC,eAAe,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIpE,EAAE,GAAGF,OAAO,CAACE,EAAE,GAAGoE,aAAa,CAAC,kBAAkB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}