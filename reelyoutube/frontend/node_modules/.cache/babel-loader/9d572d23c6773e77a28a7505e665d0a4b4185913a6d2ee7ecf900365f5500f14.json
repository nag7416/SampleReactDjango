{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.isCrossOrigin = exports.getFileExtension = exports.getAbsoluteURL = exports.parseUrl = undefined;\nvar _document = require('global/document');\nvar _document2 = _interopRequireDefault(_document);\nvar _window = require('global/window');\nvar _window2 = _interopRequireDefault(_window);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */\n/**\n * @file url.js\n * @module url\n */\nvar parseUrl = exports.parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  var a = _document2['default'].createElement('a');\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div = void 0;\n  if (addToBody) {\n    div = _document2['default'].createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\"></a>';\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    _document2['default'].body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  var details = {};\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n  if (addToBody) {\n    _document2['default'].body.removeChild(div);\n  }\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nvar getAbsoluteURL = exports.getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = _document2['default'].createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\">x</a>';\n    url = div.firstChild.href;\n  }\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */\nvar getFileExtension = exports.getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;\n    var pathParts = splitPathRe.exec(path);\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */\nvar isCrossOrigin = exports.isCrossOrigin = function isCrossOrigin(url) {\n  var winLoc = _window2['default'].location;\n  var urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n  return crossOrigin;\n};","map":{"version":3,"names":["exports","__esModule","isCrossOrigin","getFileExtension","getAbsoluteURL","parseUrl","undefined","_document","require","_document2","_interopRequireDefault","_window","_window2","obj","url","props","a","createElement","href","addToBody","host","protocol","div","innerHTML","firstChild","setAttribute","body","appendChild","details","i","length","replace","removeChild","match","path","splitPathRe","pathParts","exec","pop","toLowerCase","winLoc","location","urlInfo","srcProtocol","crossOrigin"],"sources":["C:/Users/babu7/OneDrive/Desktop/djangoyoutube2/reelyoutube/frontend/node_modules/videojs-react/node_modules/video.js/es5/utils/url.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.isCrossOrigin = exports.getFileExtension = exports.getAbsoluteURL = exports.parseUrl = undefined;\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */\n/**\n * @file url.js\n * @module url\n */\nvar parseUrl = exports.parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  var a = _document2['default'].createElement('a');\n\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div = void 0;\n\n  if (addToBody) {\n    div = _document2['default'].createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\"></a>';\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    _document2['default'].body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  var details = {};\n\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (addToBody) {\n    _document2['default'].body.removeChild(div);\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nvar getAbsoluteURL = exports.getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = _document2['default'].createElement('div');\n\n    div.innerHTML = '<a href=\"' + url + '\">x</a>';\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */\nvar getFileExtension = exports.getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;\n    var pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */\nvar isCrossOrigin = exports.isCrossOrigin = function isCrossOrigin(url) {\n  var winLoc = _window2['default'].location;\n  var urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n\n  return crossOrigin;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}