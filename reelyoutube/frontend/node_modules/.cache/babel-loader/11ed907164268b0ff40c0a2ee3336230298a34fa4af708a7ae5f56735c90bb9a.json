{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.throttle = exports.bind = undefined;\nvar _guid = require('./guid.js');\n\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */\nvar bind = exports.bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = (0, _guid.newGUID)();\n  }\n\n  // Create the new function that changes the context\n  var bound = function bound() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n  return bound;\n};\n\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */\n/**\n * @file fn.js\n * @module fn\n */\nvar throttle = exports.throttle = function throttle(fn, wait) {\n  var last = Date.now();\n  var throttled = function throttled() {\n    var now = Date.now();\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n  return throttled;\n};","map":{"version":3,"names":["exports","__esModule","throttle","bind","undefined","_guid","require","context","fn","uid","guid","newGUID","bound","apply","arguments","wait","last","Date","now","throttled"],"sources":["C:/Users/babu7/OneDrive/Desktop/djangoyoutube2/reelyoutube/frontend/node_modules/videojs-react/node_modules/video.js/es5/utils/fn.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.throttle = exports.bind = undefined;\n\nvar _guid = require('./guid.js');\n\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */\nvar bind = exports.bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = (0, _guid.newGUID)();\n  }\n\n  // Create the new function that changes the context\n  var bound = function bound() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n\n  return bound;\n};\n\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */\n/**\n * @file fn.js\n * @module fn\n */\nvar throttle = exports.throttle = function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzBD,OAAO,CAACE,QAAQ,GAAGF,OAAO,CAACG,IAAI,GAAGC,SAAS;AAE3C,IAAIC,KAAK,GAAGC,OAAO,CAAC,WAAW,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIH,IAAI,GAAGH,OAAO,CAACG,IAAI,GAAG,SAASA,IAAIA,CAACI,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACxD;EACA,IAAI,CAACD,EAAE,CAACE,IAAI,EAAE;IACZF,EAAE,CAACE,IAAI,GAAG,CAAC,CAAC,EAAEL,KAAK,CAACM,OAAO,EAAE,CAAC;EAChC;;EAEA;EACA,IAAIC,KAAK,GAAG,SAASA,KAAKA,CAAA,EAAG;IAC3B,OAAOJ,EAAE,CAACK,KAAK,CAACN,OAAO,EAAEO,SAAS,CAAC;EACrC,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACAF,KAAK,CAACF,IAAI,GAAGD,GAAG,GAAGA,GAAG,GAAG,GAAG,GAAGD,EAAE,CAACE,IAAI,GAAGF,EAAE,CAACE,IAAI;EAEhD,OAAOE,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIV,QAAQ,GAAGF,OAAO,CAACE,QAAQ,GAAG,SAASA,QAAQA,CAACM,EAAE,EAAEO,IAAI,EAAE;EAC5D,IAAIC,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EAErB,IAAIC,SAAS,GAAG,SAASA,SAASA,CAAA,EAAG;IACnC,IAAID,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;IAEpB,IAAIA,GAAG,GAAGF,IAAI,IAAID,IAAI,EAAE;MACtBP,EAAE,CAACK,KAAK,CAACT,SAAS,EAAEU,SAAS,CAAC;MAC9BE,IAAI,GAAGE,GAAG;IACZ;EACF,CAAC;EAED,OAAOC,SAAS;AAClB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}