{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.fixEvent = fixEvent;\nexports.on = on;\nexports.off = off;\nexports.trigger = trigger;\nexports.one = one;\nvar _dom = require('./dom.js');\nvar Dom = _interopRequireWildcard(_dom);\nvar _guid = require('./guid.js');\nvar Guid = _interopRequireWildcard(_guid);\nvar _log = require('./log.js');\nvar _log2 = _interopRequireDefault(_log);\nvar _window = require('global/window');\nvar _window2 = _interopRequireDefault(_window);\nvar _document = require('global/document');\nvar _document2 = _interopRequireDefault(_document);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = Dom.getElData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    Dom.removeElData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n  function returnTrue() {\n    return true;\n  }\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || _window2['default'].event;\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || _document2['default'];\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = _document2['default'].documentElement;\n      var body = _document2['default'].body;\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n    _window2['default'].addEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n  var data = Dom.getElData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n  if (!fn.guid) {\n    fn.guid = Guid.newGUID();\n  }\n  data.handlers[type].push(fn);\n  if (!data.dispatcher) {\n    data.disabled = false;\n    data.dispatcher = function (event, hash) {\n      if (data.disabled) {\n        return;\n      }\n      event = fixEvent(event);\n      var handlers = data.handlers[event.type];\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              _log2['default'].error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = {\n          passive: true\n        };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!Dom.hasElData(elem)) {\n    return;\n  }\n  var data = Dom.getElData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(elem, t);\n  };\n\n  // Are we removing all bound events?\n  if (!type) {\n    for (var t in data.handlers) {\n      removeType(t);\n    }\n    return;\n  }\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = {\n      type: event,\n      target: elem\n    };\n  }\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = Dom.getElData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\n  on(elem, type, func);\n}","map":{"version":3,"names":["exports","__esModule","fixEvent","on","off","trigger","one","_dom","require","Dom","_interopRequireWildcard","_guid","Guid","_log","_log2","_interopRequireDefault","_window","_window2","_document","_document2","obj","newObj","key","Object","prototype","hasOwnProperty","call","_cleanUpEvents","elem","type","data","getElData","handlers","length","removeEventListener","dispatcher","detachEvent","getOwnPropertyNames","disabled","removeElData","_handleMultipleEvents","fn","types","callback","forEach","event","returnTrue","returnFalse","isPropagationStopped","old","preventDefault","target","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","isImmediatePropagationStopped","clientX","undefined","doc","documentElement","body","pageX","scrollLeft","clientLeft","pageY","clientY","scrollTop","clientTop","which","charCode","keyCode","button","_supportsPassive","opts","defineProperty","get","addEventListener","e","passiveEvents","Array","isArray","guid","newGUID","push","hash","handlersCopy","slice","m","n","error","options","indexOf","passive","attachEvent","hasElData","removeType","t","splice","elemData","parent","parentNode","ownerDocument","bubbles","targetData","func","apply","arguments"],"sources":["C:/Users/babu7/OneDrive/Desktop/djangoyoutube2/reelyoutube/frontend/node_modules/videojs-react/node_modules/video.js/es5/utils/events.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.fixEvent = fixEvent;\nexports.on = on;\nexports.off = off;\nexports.trigger = trigger;\nexports.one = one;\n\nvar _dom = require('./dom.js');\n\nvar Dom = _interopRequireWildcard(_dom);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = Dom.getElData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    Dom.removeElData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || _window2['default'].event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || _document2['default'];\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = _document2['default'].documentElement;\n      var body = _document2['default'].body;\n\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    _window2['default'].addEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = Dom.getElData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = Guid.newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              _log2['default'].error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = { passive: true };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!Dom.hasElData(elem)) {\n    return;\n  }\n\n  var data = Dom.getElData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(elem, t);\n  };\n\n  // Are we removing all bound events?\n  if (!type) {\n    for (var t in data.handlers) {\n      removeType(t);\n    }\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type: event, target: elem };\n  }\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = Dom.getElData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\n  on(elem, type, func);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}