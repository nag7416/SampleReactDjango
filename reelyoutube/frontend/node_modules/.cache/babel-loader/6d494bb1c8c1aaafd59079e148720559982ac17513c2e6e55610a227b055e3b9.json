{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n/**\n * @file flash-rtmp.js\n * @module flash-rtmp\n */\n\n/**\n * Add RTMP properties to the {@link Flash} Tech.\n *\n * @param {Flash} Flash\n *        The flash tech class.\n *\n * @mixin FlashRtmpDecorator\n */\nfunction FlashRtmpDecorator(Flash) {\n  Flash.streamingFormats = {\n    'rtmp/mp4': 'MP4',\n    'rtmp/flv': 'FLV'\n  };\n\n  /**\n   * Join connection and stream with an ampersand.\n   *\n   * @param {string} connection\n   *        The connection string.\n   *\n   * @param {string} stream\n   *        The stream string.\n   */\n  Flash.streamFromParts = function (connection, stream) {\n    return connection + '&' + stream;\n  };\n\n  /**\n   * The flash parts object that contains connection and stream info.\n   *\n   * @typedef {Object} Flash~PartsObject\n   *\n   * @property {string} connection\n   *           The connection string of a source, defaults to an empty string.\n   *\n   * @property {string} stream\n   *           The stream string of the source, defaults to an empty string.\n   */\n\n  /**\n   * Convert a source url into a stream and connection parts.\n   *\n   * @param {string} src\n   *        the source url\n   *\n   * @return {Flash~PartsObject}\n   *         The parts object that contains a connection and a stream\n   */\n  Flash.streamToParts = function (src) {\n    var parts = {\n      connection: '',\n      stream: ''\n    };\n    if (!src) {\n      return parts;\n    }\n\n    // Look for the normal URL separator we expect, '&'.\n    // If found, we split the URL into two pieces around the\n    // first '&'.\n    var connEnd = src.search(/&(?!\\w+=)/);\n    var streamBegin = void 0;\n    if (connEnd !== -1) {\n      streamBegin = connEnd + 1;\n    } else {\n      // If there's not a '&', we use the last '/' as the delimiter.\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\n      if (connEnd === 0) {\n        // really, there's not a '/'?\n        connEnd = streamBegin = src.length;\n      }\n    }\n    parts.connection = src.substring(0, connEnd);\n    parts.stream = src.substring(streamBegin, src.length);\n    return parts;\n  };\n\n  /**\n   * Check if the source type is a streaming type.\n   *\n   * @param {string} srcType\n   *        The mime type to check.\n   *\n   * @return {boolean}\n   *          - True if the source type is a streaming type.\n   *          - False if the source type is not a streaming type.\n   */\n  Flash.isStreamingType = function (srcType) {\n    return srcType in Flash.streamingFormats;\n  };\n\n  // RTMP has four variations, any string starting\n  // with one of these protocols should be valid\n\n  /**\n   * Regular expression used to check if the source is an rtmp source.\n   *\n   * @property {RegExp} Flash.RTMP_RE\n   */\n  Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\n  /**\n   * Check if the source itself is a streaming type.\n   *\n   * @param {string} src\n   *        The url to the source.\n   *\n   * @return {boolean}\n   *          - True if the source url indicates that the source is streaming.\n   *          - False if the shource url indicates that the source url is not streaming.\n   */\n  Flash.isStreamingSrc = function (src) {\n    return Flash.RTMP_RE.test(src);\n  };\n\n  /**\n   * A source handler for RTMP urls\n   * @type {Object}\n   */\n  Flash.rtmpSourceHandler = {};\n\n  /**\n   * Check if Flash can play the given mime type.\n   *\n   * @param {string} type\n   *        The mime type to check\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\n    if (Flash.isStreamingType(type)) {\n      return 'maybe';\n    }\n    return '';\n  };\n\n  /**\n   * Check if Flash can handle the source natively\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Object} [options]\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\n    if (can) {\n      return can;\n    }\n    if (Flash.isStreamingSrc(source.src)) {\n      return 'maybe';\n    }\n    return '';\n  };\n\n  /**\n   * Pass the source to the flash object.\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Flash} tech\n   *        The instance of the Flash tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\n    var srcParts = Flash.streamToParts(source.src);\n    tech.setRtmpConnection(srcParts.connection);\n    tech.setRtmpStream(srcParts.stream);\n  };\n\n  // Register the native source handler\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\n  return Flash;\n}\nexports['default'] = FlashRtmpDecorator;","map":{"version":3,"names":["exports","__esModule","FlashRtmpDecorator","Flash","streamingFormats","streamFromParts","connection","stream","streamToParts","src","parts","connEnd","search","streamBegin","lastIndexOf","length","substring","isStreamingType","srcType","RTMP_RE","isStreamingSrc","test","rtmpSourceHandler","canPlayType","type","canHandleSource","source","options","can","handleSource","tech","srcParts","setRtmpConnection","setRtmpStream","registerSourceHandler"],"sources":["C:/Users/babu7/OneDrive/Desktop/djangoyoutube2/reelyoutube/frontend/node_modules/videojs-react/node_modules/video.js/es5/tech/flash-rtmp.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\n/**\n * @file flash-rtmp.js\n * @module flash-rtmp\n */\n\n/**\n * Add RTMP properties to the {@link Flash} Tech.\n *\n * @param {Flash} Flash\n *        The flash tech class.\n *\n * @mixin FlashRtmpDecorator\n */\nfunction FlashRtmpDecorator(Flash) {\n  Flash.streamingFormats = {\n    'rtmp/mp4': 'MP4',\n    'rtmp/flv': 'FLV'\n  };\n\n  /**\n   * Join connection and stream with an ampersand.\n   *\n   * @param {string} connection\n   *        The connection string.\n   *\n   * @param {string} stream\n   *        The stream string.\n   */\n  Flash.streamFromParts = function (connection, stream) {\n    return connection + '&' + stream;\n  };\n\n  /**\n   * The flash parts object that contains connection and stream info.\n   *\n   * @typedef {Object} Flash~PartsObject\n   *\n   * @property {string} connection\n   *           The connection string of a source, defaults to an empty string.\n   *\n   * @property {string} stream\n   *           The stream string of the source, defaults to an empty string.\n   */\n\n  /**\n   * Convert a source url into a stream and connection parts.\n   *\n   * @param {string} src\n   *        the source url\n   *\n   * @return {Flash~PartsObject}\n   *         The parts object that contains a connection and a stream\n   */\n  Flash.streamToParts = function (src) {\n    var parts = {\n      connection: '',\n      stream: ''\n    };\n\n    if (!src) {\n      return parts;\n    }\n\n    // Look for the normal URL separator we expect, '&'.\n    // If found, we split the URL into two pieces around the\n    // first '&'.\n    var connEnd = src.search(/&(?!\\w+=)/);\n    var streamBegin = void 0;\n\n    if (connEnd !== -1) {\n      streamBegin = connEnd + 1;\n    } else {\n      // If there's not a '&', we use the last '/' as the delimiter.\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\n      if (connEnd === 0) {\n        // really, there's not a '/'?\n        connEnd = streamBegin = src.length;\n      }\n    }\n\n    parts.connection = src.substring(0, connEnd);\n    parts.stream = src.substring(streamBegin, src.length);\n\n    return parts;\n  };\n\n  /**\n   * Check if the source type is a streaming type.\n   *\n   * @param {string} srcType\n   *        The mime type to check.\n   *\n   * @return {boolean}\n   *          - True if the source type is a streaming type.\n   *          - False if the source type is not a streaming type.\n   */\n  Flash.isStreamingType = function (srcType) {\n    return srcType in Flash.streamingFormats;\n  };\n\n  // RTMP has four variations, any string starting\n  // with one of these protocols should be valid\n\n  /**\n   * Regular expression used to check if the source is an rtmp source.\n   *\n   * @property {RegExp} Flash.RTMP_RE\n   */\n  Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\n  /**\n   * Check if the source itself is a streaming type.\n   *\n   * @param {string} src\n   *        The url to the source.\n   *\n   * @return {boolean}\n   *          - True if the source url indicates that the source is streaming.\n   *          - False if the shource url indicates that the source url is not streaming.\n   */\n  Flash.isStreamingSrc = function (src) {\n    return Flash.RTMP_RE.test(src);\n  };\n\n  /**\n   * A source handler for RTMP urls\n   * @type {Object}\n   */\n  Flash.rtmpSourceHandler = {};\n\n  /**\n   * Check if Flash can play the given mime type.\n   *\n   * @param {string} type\n   *        The mime type to check\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\n    if (Flash.isStreamingType(type)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Check if Flash can handle the source natively\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Object} [options]\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\n\n    if (can) {\n      return can;\n    }\n\n    if (Flash.isStreamingSrc(source.src)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Pass the source to the flash object.\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Flash} tech\n   *        The instance of the Flash tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\n    var srcParts = Flash.streamToParts(source.src);\n\n    tech.setRtmpConnection(srcParts.connection);\n    tech.setRtmpStream(srcParts.stream);\n  };\n\n  // Register the native source handler\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\n\n  return Flash;\n}\n\nexports['default'] = FlashRtmpDecorator;\n"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,KAAK,EAAE;EACjCA,KAAK,CAACC,gBAAgB,GAAG;IACvB,UAAU,EAAE,KAAK;IACjB,UAAU,EAAE;EACd,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACED,KAAK,CAACE,eAAe,GAAG,UAAUC,UAAU,EAAEC,MAAM,EAAE;IACpD,OAAOD,UAAU,GAAG,GAAG,GAAGC,MAAM;EAClC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,KAAK,CAACK,aAAa,GAAG,UAAUC,GAAG,EAAE;IACnC,IAAIC,KAAK,GAAG;MACVJ,UAAU,EAAE,EAAE;MACdC,MAAM,EAAE;IACV,CAAC;IAED,IAAI,CAACE,GAAG,EAAE;MACR,OAAOC,KAAK;IACd;;IAEA;IACA;IACA;IACA,IAAIC,OAAO,GAAGF,GAAG,CAACG,MAAM,CAAC,WAAW,CAAC;IACrC,IAAIC,WAAW,GAAG,KAAK,CAAC;IAExB,IAAIF,OAAO,KAAK,CAAC,CAAC,EAAE;MAClBE,WAAW,GAAGF,OAAO,GAAG,CAAC;IAC3B,CAAC,MAAM;MACL;MACAA,OAAO,GAAGE,WAAW,GAAGJ,GAAG,CAACK,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC;MAChD,IAAIH,OAAO,KAAK,CAAC,EAAE;QACjB;QACAA,OAAO,GAAGE,WAAW,GAAGJ,GAAG,CAACM,MAAM;MACpC;IACF;IAEAL,KAAK,CAACJ,UAAU,GAAGG,GAAG,CAACO,SAAS,CAAC,CAAC,EAAEL,OAAO,CAAC;IAC5CD,KAAK,CAACH,MAAM,GAAGE,GAAG,CAACO,SAAS,CAACH,WAAW,EAAEJ,GAAG,CAACM,MAAM,CAAC;IAErD,OAAOL,KAAK;EACd,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,KAAK,CAACc,eAAe,GAAG,UAAUC,OAAO,EAAE;IACzC,OAAOA,OAAO,IAAIf,KAAK,CAACC,gBAAgB;EAC1C,CAAC;;EAED;EACA;;EAEA;AACF;AACA;AACA;AACA;EACED,KAAK,CAACgB,OAAO,GAAG,mBAAmB;;EAEnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhB,KAAK,CAACiB,cAAc,GAAG,UAAUX,GAAG,EAAE;IACpC,OAAON,KAAK,CAACgB,OAAO,CAACE,IAAI,CAACZ,GAAG,CAAC;EAChC,CAAC;;EAED;AACF;AACA;AACA;EACEN,KAAK,CAACmB,iBAAiB,GAAG,CAAC,CAAC;;EAE5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEnB,KAAK,CAACmB,iBAAiB,CAACC,WAAW,GAAG,UAAUC,IAAI,EAAE;IACpD,IAAIrB,KAAK,CAACc,eAAe,CAACO,IAAI,CAAC,EAAE;MAC/B,OAAO,OAAO;IAChB;IAEA,OAAO,EAAE;EACX,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErB,KAAK,CAACmB,iBAAiB,CAACG,eAAe,GAAG,UAAUC,MAAM,EAAEC,OAAO,EAAE;IACnE,IAAIC,GAAG,GAAGzB,KAAK,CAACmB,iBAAiB,CAACC,WAAW,CAACG,MAAM,CAACF,IAAI,CAAC;IAE1D,IAAII,GAAG,EAAE;MACP,OAAOA,GAAG;IACZ;IAEA,IAAIzB,KAAK,CAACiB,cAAc,CAACM,MAAM,CAACjB,GAAG,CAAC,EAAE;MACpC,OAAO,OAAO;IAChB;IAEA,OAAO,EAAE;EACX,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,KAAK,CAACmB,iBAAiB,CAACO,YAAY,GAAG,UAAUH,MAAM,EAAEI,IAAI,EAAEH,OAAO,EAAE;IACtE,IAAII,QAAQ,GAAG5B,KAAK,CAACK,aAAa,CAACkB,MAAM,CAACjB,GAAG,CAAC;IAE9CqB,IAAI,CAACE,iBAAiB,CAACD,QAAQ,CAACzB,UAAU,CAAC;IAC3CwB,IAAI,CAACG,aAAa,CAACF,QAAQ,CAACxB,MAAM,CAAC;EACrC,CAAC;;EAED;EACAJ,KAAK,CAAC+B,qBAAqB,CAAC/B,KAAK,CAACmB,iBAAiB,CAAC;EAEpD,OAAOnB,KAAK;AACd;AAEAH,OAAO,CAAC,SAAS,CAAC,GAAGE,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}